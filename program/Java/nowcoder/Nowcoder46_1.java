package nowcoder;
// 约瑟夫环问题:
// 0~n-1这n个数字排成一个圆圈,从数字0开始每次从这个圆圈里删除第m个数字,
// 然后从删除位置的下一个位置开始计数,继续删除第m个数字.
// 求出这个圆圈里剩下的最后一个数字.
// PS:如果不存在此数字,则返回-1
// PS:不要想着自定义额外的数据结构(如:链表节点),只能使用已有的数据结构.
public class Nowcoder46_1{
    // 方法2:递归法(自顶向下)
    // 思路:由于是循环查找,因此可以将第一个查找到的数字记为k,则删除k后剩下的数字为
    // 0,1,2...k-1,k+1,...n共计n-1个数,而剩下的数可以组成k+1,n...0,1,2...k-1,可以视
    // 为从数值为k+1的数开始查找,即变成子问题f(n-1,m),只需要找到这n-1个数中最后剩下
    // 的数的下标即可,而k=(m-1)%n,故f(n,m)=(k + f(n-1,m) + 1)%n = (m + f(n-1,m))%n
    // 边界条件为:当n=1时,f(n,m)=0
    // 时间复杂度:O(n),空间复杂度:O(1)
    public int LastRemaining_Solution(int n, int m) {
        // 排除特殊情况
        if( n<1 || m<=0) return -1;
        // 递归求解
        return solve(n,m);
    }
    private int solve(int n,int m){
        // 设置递归出口
        if(n == 1) return 0;
        return (m + solve(n-1,m))%n;
    }
}