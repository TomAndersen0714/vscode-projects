package java.nowcoder;
// 约瑟夫环问题:
// 0~n-1这n个数字排成一个圆圈,从数字0开始每次从这个圆圈里删除第m个数字,
// 然后从删除位置的下一个位置开始计数,继续删除第m个数字.
// 求出这个圆圈里剩下的最后一个数字.
// PS:如果不存在此数字,则返回-1
// PS:不要想着自定义额外的数据结构(如:链表节点),只能使用已有的数据结构.
public class Nowcoder46_2{
    // 方法3:迭代法(自底向上)
    // 思路:由于是循环查找,因此可以将第一个查找到的数字记为k,则删除k后剩下的数字为
    // 0,1,2...k-1,k+1,...n共计n-1个数,而剩下的数可以组成k+1,n...0,1,2...k-1,可以视
    // 为从数值为k+1的数开始查找,即变成子问题f(n-1,m),只需要找到这n-1个数中最后剩下
    // 的数的下标即可,而k=(m-1)%n,故f(n,m)=(k + f(n-1,m) + 1)%n = (m + f(n-1,m))%n
    // 边界条件为:当n=1时,f(n,m)=0.思路和之前方法2相同,主要区别在于方法2是递归,方法3
    // 是迭代.
    // 时间复杂度:O(n),空间复杂度:O(1)
    public int LastRemaining_Solution(int n, int m) {
        // 排除特殊情况
        if(n<=0 || m<=0) return -1;
        // 迭代计算
        int index = 0;
        for(int i=2; i<=n; i++){
            index = (m + index)%i;
        }
        // 返回最终位置
        return index;
    }
}